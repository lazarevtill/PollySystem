File: ./backend/alembic/env.py
----------------------------------------
# alembic/env.py
import os
import sys
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# Add the parent directory to the Python path
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

# Import your models
from app.core.database import Base
from app.models.machine import Machine  # Import all your models here

# this is the Alembic Config object
config = context.config

# Interpret the config file for Python logging
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Set target metadata
target_metadata = Base.metadata

def run_migrations_offline() -> None:
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online() -> None:
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, 
            target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()



File: ./backend/alembic/versions/ad31280797e5_initial_migration.py
----------------------------------------
"""Initial migration

Revision ID: ad31280797e5
Revises: 
Create Date: 2024-12-05 23:34:17.185958

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'ad31280797e5'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('machines',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(), nullable=True),
    sa.Column('host', sa.String(), nullable=True),
    sa.Column('port', sa.Integer(), nullable=True),
    sa.Column('user', sa.String(), nullable=True),
    sa.Column('password', sa.String(), nullable=True),
    sa.Column('ssh_key_path', sa.String(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_machines_host'), 'machines', ['host'], unique=True)
    op.create_index(op.f('ix_machines_id'), 'machines', ['id'], unique=False)
    op.create_index(op.f('ix_machines_name'), 'machines', ['name'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_machines_name'), table_name='machines')
    op.drop_index(op.f('ix_machines_id'), table_name='machines')
    op.drop_index(op.f('ix_machines_host'), table_name='machines')
    op.drop_table('machines')
    # ### end Alembic commands ###



File: ./backend/alembic.ini
----------------------------------------
# alembic.ini
[alembic]
script_location = alembic
sqlalchemy.url = sqlite:///./pollysystem.db

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S



File: ./backend/app/core/auth.py
----------------------------------------
# Future implementation for auth & RBAC
# Currently just a placeholder for future expansion
# No authentication enforced now.
def dummy_auth():
    pass



File: ./backend/app/core/config.py
----------------------------------------
import os
from dotenv import load_dotenv

load_dotenv()

class Settings:
    # Configuration values (adjust as needed)
    # For simplicity, hardcoded values here:
    SSH_DEFAULT_PORT = 22
    JWT_SECRET = "supersecretjwtkey"  # Auth not implemented yet
    # You can expand this class as needed
    DEBUG = True

settings = Settings()



File: ./backend/app/core/database.py
----------------------------------------
# app/core/database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = "sqlite:///./pollysystem.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()



File: ./backend/app/core/docker_utils.py
----------------------------------------
from app.core.ssh_utils import run_command_on_machine

def check_and_install_docker(host, port, user, ssh_key, password):
    # Check if docker is installed
    check_cmd = "which docker"
    result = run_command_on_machine(host, port, user, check_cmd, ssh_key, password)
    if "docker" not in result:
        # run installation script
        install_script = open("scripts/docker_install_check.sh", "r").read()
        return run_command_on_machine(host, port, user, install_script, ssh_key, password)
    return "Docker already installed"

def run_docker_compose_command(host, port, user, command, ssh_key, password):
    # Assume docker-compose.yml present on the machine or handle it accordingly
    # For demonstration: run docker compose up/down from a fixed directory
    cmd = f"cd ~/ && docker compose {command}"
    return run_command_on_machine(host, port, user, cmd, ssh_key, password)



File: ./backend/app/core/metrics_utils.py
----------------------------------------
# app/core/metrics_utils.py
from app.core.ssh_utils import run_command_on_machine, SSHConnectionError
import logging

logger = logging.getLogger(__name__)

class MetricsCollectionError(Exception):
    pass

def get_machine_metrics(host: str, port: int, user: str, ssh_key: str = None, password: str = None):
    """Get CPU and memory metrics from a remote machine."""
    try:
        # Simpler, more reliable commands
        cpu_cmd = "top -bn1 | grep 'Cpu(s)' | awk '{print $2}' || echo '0.0'"
        mem_cmd = "free -m | awk 'NR==2{printf \"%d,%d\", $3,$2}' || echo '0,1'"
        
        try:
            cpu_usage_str = run_command_on_machine(host, port, user, cpu_cmd, ssh_key, password)
            cpu_usage = float(cpu_usage_str) if cpu_usage_str.strip() else 0.0
        except (ValueError, TypeError) as e:
            logger.warning(f"Failed to parse CPU metrics for {host}: {str(e)}")
            cpu_usage = 0.0

        try:
            mem_usage_str = run_command_on_machine(host, port, user, mem_cmd, ssh_key, password)
            used_mem, total_mem = map(int, mem_usage_str.split(",")) if "," in mem_usage_str else (0, 1)
        except (ValueError, AttributeError) as e:
            logger.warning(f"Failed to parse memory metrics for {host}: {str(e)}")
            used_mem, total_mem = 0, 1

        return {
            "cpu_usage_percent": round(cpu_usage, 2),
            "memory_used_mb": used_mem,
            "memory_total_mb": total_mem,
            "status": "ok"
        }

    except SSHConnectionError as e:
        logger.error(f"SSH connection error for {host}: {str(e)}")
        return {
            "cpu_usage_percent": 0.0,
            "memory_used_mb": 0,
            "memory_total_mb": 1,
            "status": "error",
            "error": f"Connection failed: {str(e)}"
        }
    except Exception as e:
        logger.error(f"Failed to collect metrics for {host}: {str(e)}")
        return {
            "cpu_usage_percent": 0.0,
            "memory_used_mb": 0,
            "memory_total_mb": 1,
            "status": "error",
            "error": f"Failed to collect metrics: {str(e)}"
        }


File: ./backend/app/core/ssh_manager.py
----------------------------------------
# app/core/ssh_manager.py
import os
import paramiko
from pathlib import Path
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
import logging

logger = logging.getLogger(__name__)

class SSHManager:
    def __init__(self, ssh_dir="~/.ssh/pollysystem"):
        self.ssh_dir = os.path.expanduser(ssh_dir)
        Path(self.ssh_dir).mkdir(parents=True, exist_ok=True)
        self.private_key_path = os.path.join(self.ssh_dir, "id_rsa")
        self.public_key_path = os.path.join(self.ssh_dir, "id_rsa.pub")
        self._ensure_keys_exist()

    def _ensure_keys_exist(self):
        """Ensure SSH key pair exists, generate if it doesn't."""
        if not os.path.exists(self.private_key_path) or not os.path.exists(self.public_key_path):
            logger.info("Generating new SSH key pair...")
            self._generate_key_pair()
        else:
            # Validate existing keys
            try:
                paramiko.RSAKey.from_private_key_file(self.private_key_path)
            except Exception as e:
                logger.warning(f"Invalid existing SSH key, regenerating: {e}")
                self._generate_key_pair()

    def _generate_key_pair(self):
        """Generate a new RSA key pair."""
        try:
            # Generate private key
            private_key = rsa.generate_private_key(
                public_exponent=65537,
                key_size=2048,
                backend=default_backend()
            )

            # Generate private key in PEM format
            pem_private = private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            )

            # Generate public key in OpenSSH format
            public_key = private_key.public_key()
            pem_public = public_key.public_bytes(
                encoding=serialization.Encoding.OpenSSH,
                format=serialization.PublicFormat.OpenSSH
            )

            # Write private key
            with open(self.private_key_path, 'wb') as f:
                f.write(pem_private)
            os.chmod(self.private_key_path, 0o600)

            # Write public key
            with open(self.public_key_path, 'wb') as f:
                f.write(pem_public)
            os.chmod(self.public_key_path, 0o644)

            logger.info("Successfully generated new SSH key pair")

        except Exception as e:
            logger.error(f"Failed to generate SSH key pair: {e}")
            raise

    def get_public_key(self):
        """Get the public key content."""
        try:
            with open(self.public_key_path, 'r') as f:
                return f.read().strip()
        except Exception as e:
            logger.error(f"Failed to read public key: {e}")
            raise

    def deploy_key(self, host, port, user, password):
        """Deploy the public key to a remote host."""
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
        try:
            logger.info(f"Connecting to {host} to deploy SSH key...")
            ssh.connect(
                hostname=host,
                port=port,
                username=user,
                password=password,
                timeout=10
            )

            public_key = self.get_public_key()
            commands = [
                "mkdir -p ~/.ssh",
                "chmod 700 ~/.ssh",
                f"echo '{public_key}' >> ~/.ssh/authorized_keys",
                "chmod 600 ~/.ssh/authorized_keys",
                "sort -u ~/.ssh/authorized_keys -o ~/.ssh/authorized_keys"
            ]

            for cmd in commands:
                stdin, stdout, stderr = ssh.exec_command(cmd)
                exit_status = stdout.channel.recv_exit_status()
                if exit_status != 0:
                    error = stderr.read().decode().strip()
                    raise Exception(f"Command failed: {error}")

            logger.info(f"Successfully deployed SSH key to {host}")
            return True

        except Exception as e:
            logger.error(f"Failed to deploy SSH key to {host}: {e}")
            raise

        finally:
            ssh.close()

ssh_manager = SSHManager()

# Test the SSH key generation on import
try:
    ssh_manager._ensure_keys_exist()
except Exception as e:
    logger.error(f"Failed to initialize SSH manager: {e}")
    raise


File: ./backend/app/core/ssh_utils.py
----------------------------------------
# app/core/ssh_utils.py
import paramiko
import socket
import os
import io
import logging
import tempfile
from contextlib import contextmanager
from typing import Optional, Union, Any
from pathlib import Path

logger = logging.getLogger(__name__)

class SSHConnectionError(Exception):
    pass

class SSHKeyError(Exception):
    pass

def normalize_key_content(key_content: str) -> str:
    """Normalize SSH key content by fixing line endings and format."""
    # Remove any carriage returns and normalize to Unix line endings
    key_content = key_content.replace('\r\n', '\n').replace('\r', '\n')
    lines = key_content.strip().split('\n')
    
    # Check if this is an OpenSSH format key
    if not any(line.startswith('-----BEGIN ') for line in lines):
        return key_content

    # Properly format OpenSSH key
    formatted_lines = []
    in_body = False
    last_was_header = False

    for line in lines:
        if line.startswith('-----BEGIN '):
            formatted_lines.append(line)
            in_body = True
            last_was_header = True
        elif line.startswith('-----END '):
            if not formatted_lines[-1] == '':
                formatted_lines.append('')
            formatted_lines.append(line)
            in_body = False
        elif in_body:
            if last_was_header:
                formatted_lines.append('')
                last_was_header = False
            formatted_lines.append(line)

    return '\n'.join(formatted_lines)

def detect_key_type(key_content: str) -> str:
    """Detect the type of SSH key from its content."""
    normalized = normalize_key_content(key_content)
    
    if "OPENSSH PRIVATE KEY" in normalized:
        return "openssh"
    elif "RSA PRIVATE KEY" in normalized:
        return "rsa"
    elif "DSA PRIVATE KEY" in normalized:
        return "dsa"
    elif "EC PRIVATE KEY" in normalized:
        return "ecdsa"
    elif "PRIVATE KEY" in normalized:  # Generic key format
        return "generic"
    else:
        return "unknown"

@contextmanager
def create_temp_key_file(key_content: str):
    """Create a temporary file with SSH key content."""
    temp_file = None
    try:
        temp_file = tempfile.NamedTemporaryFile(mode='w', delete=False)
        temp_file.write(normalize_key_content(key_content))
        temp_file.flush()
        os.chmod(temp_file.name, 0o600)
        yield temp_file.name
    finally:
        if temp_file and os.path.exists(temp_file.name):
            try:
                os.unlink(temp_file.name)
            except Exception as e:
                logger.warning(f"Failed to remove temporary key file: {e}")

def load_ssh_key(key_path_or_content: str, passphrase: Optional[str] = None) -> Any:
    """
    Load an SSH key from a file path or content string.
    Supports RSA, DSA, ECDSA, Ed25519, and OpenSSH key formats.
    """
    key_content = key_path_or_content
    if os.path.exists(key_path_or_content):
        with open(key_path_or_content, 'r') as f:
            key_content = f.read()

    # Normalize the key content
    key_content = normalize_key_content(key_content)
    key_type = detect_key_type(key_content)
    logger.debug(f"Detected key type: {key_type}")

    # Map of key types to their respective paramiko classes and names
    key_handlers = [
        (paramiko.RSAKey, "RSA", lambda: paramiko.RSAKey.from_private_key),
        (paramiko.DSSKey, "DSS", lambda: paramiko.DSSKey.from_private_key),
        (paramiko.ECDSAKey, "ECDSA", lambda: paramiko.ECDSAKey.from_private_key),
        (paramiko.Ed25519Key, "Ed25519", lambda: paramiko.Ed25519Key.from_private_key)
    ]

    errors = []
    # Try loading with StringIO first (memory-based)
    for key_class, key_name, key_loader in key_handlers:
        try:
            key_file = io.StringIO(key_content)
            if passphrase:
                key = key_loader()(key_file, password=passphrase)
            else:
                try:
                    key = key_loader()(key_file)
                except paramiko.ssh_exception.PasswordRequiredException:
                    errors.append(f"{key_name}: Key is encrypted and requires a passphrase")
                    continue
            logger.info(f"Successfully loaded {key_name} key from content")
            return key
        except Exception as e:
            errors.append(f"{key_name} (memory): {str(e)}")

    # If memory loading fails, try with temporary file
    with create_temp_key_file(key_content) as temp_path:
        for key_class, key_name, key_loader in key_handlers:
            try:
                if passphrase:
                    key = key_class.from_private_key_file(temp_path, password=passphrase)
                else:
                    try:
                        key = key_class.from_private_key_file(temp_path)
                    except paramiko.ssh_exception.PasswordRequiredException:
                        errors.append(f"{key_name}: Key is encrypted and requires a passphrase")
                        continue
                logger.info(f"Successfully loaded {key_name} key from file")
                return key
            except Exception as e:
                errors.append(f"{key_name} (file): {str(e)}")

    error_msg = f"Failed to load SSH key (type: {key_type}). Errors: " + '; '.join(errors)
    logger.error(error_msg)
    raise SSHKeyError(error_msg)

@contextmanager
def ssh_connection(
    host: str,
    port: int,
    username: str,
    ssh_key: Optional[str] = None,
    password: Optional[str] = None,
    key_passphrase: Optional[str] = None,
    timeout: int = 10
):
    """Create an SSH connection with comprehensive error handling."""
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    
    try:
        if ssh_key:
            try:
                pkey = load_ssh_key(ssh_key, key_passphrase)
                ssh.connect(
                    hostname=host,
                    port=port,
                    username=username,
                    pkey=pkey,
                    timeout=timeout,
                    look_for_keys=False
                )
            except Exception as e:
                raise SSHConnectionError(f"Failed to connect with SSH key: {str(e)}")
        else:
            try:
                ssh.connect(
                    hostname=host,
                    port=port,
                    username=username,
                    password=password,
                    timeout=timeout,
                    look_for_keys=False
                )
            except Exception as e:
                raise SSHConnectionError(f"Failed to connect with password: {str(e)}")
            
        yield ssh
        
    except socket.timeout:
        raise SSHConnectionError(f"Connection timed out while connecting to {host}")
    except paramiko.AuthenticationException:
        raise SSHConnectionError(
            f"Authentication failed for {username}@{host}. " 
            f"{'Key is invalid or encrypted' if ssh_key else 'Invalid password'}"
        )
    except Exception as e:
        raise SSHConnectionError(f"Failed to connect to {host}: {str(e)}")
    finally:
        ssh.close()

def run_command_on_machine(
    host: str,
    port: int,
    user: str,
    command: str,
    ssh_key: Optional[str] = None,
    password: Optional[str] = None,
    key_passphrase: Optional[str] = None,
    timeout: int = 10
) -> str:
    """Execute a command on a remote machine via SSH with comprehensive error handling."""
    try:
        with ssh_connection(
            host, port, user, ssh_key, password, key_passphrase, timeout
        ) as ssh:
            # Set up the channel with proper handling
            transport = ssh.get_transport()
            if not transport:
                raise SSHConnectionError("Failed to establish SSH transport")
            
            # Open channel and set timeout
            channel = transport.open_session()
            channel.settimeout(timeout)
            
            # Execute command
            channel.exec_command(command)
            
            # Read output and error streams
            stdout = channel.makefile('r')
            stderr = channel.makefile_stderr('r')
            
            # Get output and error content
            output = stdout.read().strip()
            error = stderr.read().strip()
            
            # Get exit status
            exit_status = channel.recv_exit_status()
            
            if exit_status != 0:
                error_msg = error if error else f"Command exited with status {exit_status}"
                raise SSHConnectionError(f"Command failed: {error_msg}")
            
            return output.decode('utf-8') if isinstance(output, bytes) else output
            
    except SSHConnectionError:
        raise
    except Exception as e:
        logger.error(f"Failed to execute command on {host}: {str(e)}")
        raise SSHConnectionError(str(e))

class SSHKeyManager:
    """Manage SSH keys, including generation and deployment."""
    
    def __init__(self, ssh_dir: str = "~/.ssh/pollysystem"):
        self.ssh_dir = os.path.expanduser(ssh_dir)
        self.private_key_path = os.path.join(self.ssh_dir, "id_rsa")
        self.public_key_path = os.path.join(self.ssh_dir, "id_rsa.pub")
        self._ensure_ssh_dir()

    def _ensure_ssh_dir(self):
        """Ensure SSH directory exists with proper permissions."""
        os.makedirs(self.ssh_dir, mode=0o700, exist_ok=True)

    def generate_key_pair(self, key_type: str = "rsa", bits: int = 2048):
        """Generate a new SSH key pair."""
        if key_type.lower() == "rsa":
            key = paramiko.RSAKey.generate(bits)
        elif key_type.lower() == "dsa":
            key = paramiko.DSSKey.generate(bits)
        elif key_type.lower() == "ecdsa":
            key = paramiko.ECDSAKey.generate()
        else:
            raise ValueError(f"Unsupported key type: {key_type}")

        # Save private key
        key.write_private_key_file(self.private_key_path)
        os.chmod(self.private_key_path, 0o600)

        # Save public key
        with open(self.public_key_path, 'w') as f:
            f.write(f"{key.get_name()} {key.get_base64()} pollysystem\n")
        os.chmod(self.public_key_path, 0o644)

    def deploy_key(self, host: str, port: int, user: str, password: str) -> bool:
        """Deploy public key to remote host."""
        if not os.path.exists(self.public_key_path):
            self.generate_key_pair()

        with open(self.public_key_path, 'r') as f:
            public_key = f.read().strip()

        try:
            with ssh_connection(host, port, user, password=password) as ssh:
                commands = [
                    "mkdir -p ~/.ssh",
                    "chmod 700 ~/.ssh",
                    f"echo '{public_key}' >> ~/.ssh/authorized_keys",
                    "chmod 600 ~/.ssh/authorized_keys",
                    "sort -u ~/.ssh/authorized_keys -o ~/.ssh/authorized_keys"
                ]

                for cmd in commands:
                    stdin, stdout, stderr = ssh.exec_command(cmd)
                    if stderr.read():
                        raise SSHConnectionError(f"Failed to execute: {cmd}")

                return True

        except Exception as e:
            raise SSHConnectionError(f"Failed to deploy key: {str(e)}")

ssh_manager = SSHKeyManager()


File: ./backend/app/main.py
----------------------------------------
# app/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from loguru import logger

from app.core.config import settings
from app.core.database import Base, engine
from app.plugins import load_plugins

# Create database tables
Base.metadata.create_all(bind=engine)

app = FastAPI(title="PollySystem", version="1.0.0")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Adjust to your frontend origin
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Load all plugins dynamically
load_plugins(app)

@app.get("/health")
def health_check():
    return {"status": "healthy"}

logger.info("PollySystem backend started")


File: ./backend/app/models/machine.py
----------------------------------------
# app/models/machine.py
from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.sql import func
from app.core.database import Base

class Machine(Base):
    __tablename__ = "machines"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True)
    host = Column(String, unique=True, index=True)
    port = Column(Integer, default=22)
    user = Column(String)
    password = Column(String, nullable=True)
    ssh_key_path = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())



File: ./backend/app/plugins/commands/routes.py
----------------------------------------
# app/plugins/commands/routes.py
from fastapi import APIRouter, HTTPException, Depends, Body
from pydantic import BaseModel
from typing import Dict
from sqlalchemy.orm import Session
from app.core.database import get_db
from app.models.machine import Machine
from app.core.ssh_utils import run_command_on_machine

router = APIRouter(prefix="/api/v1/commands", tags=["commands"])

class CommandRequest(BaseModel):
    command: str

def register(app):
    app.include_router(router)

@router.post("/run_all")
async def run_on_all(request: CommandRequest, db: Session = Depends(get_db)) -> Dict[str, Dict[str, str]]:
    """
    Run a command on all registered machines.
    POST body should be JSON: { "command": "your_command_here" }
    """
    command = request.command.strip()
    if not command:
        raise HTTPException(status_code=400, detail="Command cannot be empty")

    # Get all machines
    machines = db.query(Machine).all()
    if not machines:
        raise HTTPException(status_code=400, detail="No machines available")

    results = {}
    for machine in machines:
        try:
            output = run_command_on_machine(
                host=machine.host,
                port=machine.port,
                user=machine.user,
                command=command,
                ssh_key=machine.ssh_key_path,
                password=machine.password
            )
            results[machine.host] = output
        except Exception as e:
            results[machine.host] = f"Error: {str(e)}"

    return {"results": results}



File: ./backend/app/plugins/commands/__init__.py
----------------------------------------



File: ./backend/app/plugins/docker_manager/routes.py
----------------------------------------
# app/plugins/docker_manager/routes.py
from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session
from typing import Dict
from app.core.database import get_db
from app.models.machine import Machine
from app.core.docker_utils import check_and_install_docker, run_docker_compose_command

router = APIRouter(prefix="/api/v1/docker", tags=["docker"])

def register(app):
    app.include_router(router)

@router.post("/install", response_model=Dict[str, Dict[str, str]])
async def install_docker_on_all(db: Session = Depends(get_db)):
    """Install Docker on all registered machines."""
    machines = db.query(Machine).all()
    if not machines:
        raise HTTPException(status_code=400, detail="No machines available")

    install_results = {}
    for machine in machines:
        try:
            res = check_and_install_docker(
                host=machine.host,
                port=machine.port,
                user=machine.user,
                ssh_key=machine.ssh_key_path,
                password=machine.password
            )
            install_results[machine.host] = res
        except Exception as e:
            install_results[machine.host] = f"Error: {str(e)}"

    return {
        "status": "installation_checked",
        "details": install_results
    }

@router.post("/compose/run", response_model=Dict[str, Dict[str, str]])
async def compose_run(db: Session = Depends(get_db)):
    """Run docker-compose up on all machines."""
    machines = db.query(Machine).all()
    if not machines:
        raise HTTPException(status_code=400, detail="No machines available")

    results = {}
    for machine in machines:
        try:
            res = run_docker_compose_command(
                host=machine.host,
                port=machine.port,
                user=machine.user,
                command="up -d",
                ssh_key=machine.ssh_key_path,
                password=machine.password
            )
            results[machine.host] = res
        except Exception as e:
            results[machine.host] = f"Error: {str(e)}"

    return {
        "status": "compose_run_triggered",
        "results": results
    }

@router.post("/compose/stop", response_model=Dict[str, Dict[str, str]])
async def compose_stop(db: Session = Depends(get_db)):
    """Stop docker-compose on all machines."""
    machines = db.query(Machine).all()
    if not machines:
        raise HTTPException(status_code=400, detail="No machines available")

    results = {}
    for machine in machines:
        try:
            res = run_docker_compose_command(
                host=machine.host,
                port=machine.port,
                user=machine.user,
                command="down",
                ssh_key=machine.ssh_key_path,
                password=machine.password
            )
            results[machine.host] = res
        except Exception as e:
            results[machine.host] = f"Error: {str(e)}"

    return {
        "status": "compose_stopped",
        "results": results
    }


File: ./backend/app/plugins/docker_manager/__init__.py
----------------------------------------



File: ./backend/app/plugins/machines/models.py
----------------------------------------
from pydantic import BaseModel, Field
from typing import Optional

class MachineCreate(BaseModel):
    name: str = Field(..., min_length=1)
    host: str = Field(..., min_length=1)
    port: int = Field(22, ge=1, le=65535)
    user: str = Field(..., min_length=1)
    password: Optional[str] = None
    ssh_key: Optional[str] = None



File: ./backend/app/plugins/machines/routes.py
----------------------------------------
# app/plugins/machines/routes.py
from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session
from typing import List, Optional, Dict
import os
import tempfile
import logging
from . import schemas
from app.models.machine import Machine
from app.core.database import get_db
from app.core.ssh_utils import run_command_on_machine, create_temp_key_file, load_ssh_key
from app.core.metrics_utils import get_machine_metrics

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/v1/machines", tags=["machines"])

def test_connection(host: str, port: int, user: str, ssh_key: Optional[str] = None, password: Optional[str] = None) -> bool:
    """Test SSH connection with provided credentials."""
    try:
        result = run_command_on_machine(
            host=host,
            port=port,
            user=user,
            command="echo 'Connection test successful'",
            ssh_key=ssh_key,
            password=password
        )
        return "Connection test successful" in result
    except Exception as e:
        logger.error(f"Connection test failed for {host}: {str(e)}")
        raise Exception(f"Connection test failed: {str(e)}")

def register(app):
    app.include_router(router)

@router.get("/", response_model=List[schemas.MachineResponse])
async def list_machines(db: Session = Depends(get_db)):
    """List all registered machines."""
    return db.query(Machine).all()

@router.post("/", response_model=schemas.MachineResponse)
async def add_machine(machine: schemas.MachineCreate, db: Session = Depends(get_db)):
    """Add a new machine with either SSH key or password authentication."""
    if db.query(Machine).filter(Machine.host == machine.host).first():
        raise HTTPException(status_code=400, detail="Machine already exists")

    try:
        ssh_key_path = None
        tmp_key_file = None

        # Handle SSH key authentication
        if machine.ssh_key:
            try:
                # Create a temporary file for the SSH key
                tmp_key_file = tempfile.NamedTemporaryFile(mode='w', delete=False)
                tmp_key_file.write(machine.ssh_key)
                tmp_key_file.flush()
                os.chmod(tmp_key_file.name, 0o600)
                ssh_key_path = tmp_key_file.name

                # Test connection with SSH key
                test_connection(
                    host=machine.host,
                    port=machine.port,
                    user=machine.user,
                    ssh_key=ssh_key_path
                )

            except Exception as e:
                if tmp_key_file and os.path.exists(tmp_key_file.name):
                    os.unlink(tmp_key_file.name)
                raise HTTPException(
                    status_code=400,
                    detail=f"SSH key authentication failed: {str(e)}"
                )

        # Handle password authentication
        elif machine.password:
            try:
                test_connection(
                    host=machine.host,
                    port=machine.port,
                    user=machine.user,
                    password=machine.password
                )
            except Exception as e:
                raise HTTPException(
                    status_code=400,
                    detail=f"Password authentication failed: {str(e)}"
                )
        else:
            raise HTTPException(
                status_code=400,
                detail="Either SSH key or password must be provided"
            )

        # Create machine record
        db_machine = Machine(
            name=machine.name,
            host=machine.host,
            port=machine.port,
            user=machine.user,
            password=machine.password if not machine.ssh_key else None,
            ssh_key_path=ssh_key_path
        )

        try:
            db.add(db_machine)
            db.commit()
            db.refresh(db_machine)
            return db_machine
        except Exception as e:
            if ssh_key_path and os.path.exists(ssh_key_path):
                os.unlink(ssh_key_path)
            raise HTTPException(
                status_code=400,
                detail=f"Failed to add machine to database: {str(e)}"
            )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to add machine {machine.host}: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))

@router.delete("/{host}", response_model=schemas.StatusResponse)
async def delete_machine(host: str, db: Session = Depends(get_db)):
    """Delete a machine by host."""
    machine = db.query(Machine).filter(Machine.host == host).first()
    if not machine:
        raise HTTPException(status_code=404, detail="Machine not found")
    
    # Clean up SSH key file if it exists
    if machine.ssh_key_path and os.path.exists(machine.ssh_key_path):
        try:
            os.unlink(machine.ssh_key_path)
        except Exception as e:
            logger.warning(f"Failed to delete SSH key file {machine.ssh_key_path}: {e}")
    
    db.delete(machine)
    db.commit()
    
    return {"status": "machine_deleted"}

@router.get("/{host}/metrics", response_model=schemas.MachineMetrics)
async def get_machine_metrics_endpoint(host: str, db: Session = Depends(get_db)):
    """Get metrics for a specific machine."""
    machine = db.query(Machine).filter(Machine.host == host).first()
    if not machine:
        raise HTTPException(status_code=404, detail="Machine not found")
    
    try:
        metrics = get_machine_metrics(
            machine.host,
            machine.port,
            machine.user,
            machine.ssh_key_path,
            machine.password
        )
        return metrics
    except Exception as e:
        logger.error(f"Failed to get metrics for {host}: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get metrics: {str(e)}")


File: ./backend/app/plugins/machines/schemas.py
----------------------------------------
# app/plugins/machines/schemas.py
from pydantic import BaseModel, Field, validator
from typing import Optional
from datetime import datetime

class MachineBase(BaseModel):
    name: str = Field(..., min_length=1)
    host: str = Field(..., min_length=1)
    port: int = Field(22, ge=1, le=65535)
    user: str = Field(..., min_length=1)

class MachineCreate(MachineBase):
    password: Optional[str] = None
    ssh_key: Optional[str] = None

    @validator('ssh_key')
    def validate_ssh_key(cls, v):
        if v is not None:
            v = v.strip()
            if not ('BEGIN' in v and 'PRIVATE KEY' in v and 'END' in v):
                raise ValueError("Invalid SSH key format. Must be a private key file.")
        return v

    @validator('*')
    def no_empty_strings(cls, v):
        if isinstance(v, str) and len(v.strip()) == 0:
            raise ValueError("Field cannot be empty")
        return v

class MachineResponse(MachineBase):
    id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

class MachineMetrics(BaseModel):
    cpu_usage_percent: float
    memory_used_mb: int
    memory_total_mb: int
    status: str = "ok"
    error: Optional[str] = None

class StatusResponse(BaseModel):
    status: str


File: ./backend/app/plugins/machines/__init__.py
----------------------------------------



File: ./backend/app/plugins/__init__.py
----------------------------------------
import importlib
import os
from fastapi import FastAPI

def load_plugins(app: FastAPI):
    plugins_dir = os.path.dirname(__file__)
    for item in os.listdir(plugins_dir):
        if item.startswith("__"):
            continue
        full_path = os.path.join(plugins_dir, item)
        if os.path.isdir(full_path):
            routes_file = os.path.join(full_path, "routes.py")
            if os.path.exists(routes_file):
                module_name = f"app.plugins.{item}.routes"
                mod = importlib.import_module(module_name)
                if hasattr(mod, "register"):
                    mod.register(app)



File: ./backend/tests/test_machines.py
----------------------------------------



File: ./docker/docker-compose.yml
----------------------------------------
version: "3.9"
services:
  backend:
    build: ../backend/app
    container_name: polly_backend
    environment:
      - PYTHONUNBUFFERED=1
    ports:
      - "8000:8000"
  
  frontend:
    build: ../frontend
    container_name: polly_frontend
    ports:
      - "3000:3000"
    depends_on:
      - backend
    environment:
      - REACT_APP_API_URL=http://localhost:8000

networks:
  default:
    name: polly_net



File: ./docker/prometheus/prometheus.yml
----------------------------------------



File: ./frontend/next-env.d.ts
----------------------------------------
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/building-your-application/configuring/typescript for more information.



File: ./frontend/next.config.js
----------------------------------------
/** @type {import('next').NextConfig} */
const nextConfig = {
    reactStrictMode: true,
    // If you want TS inside src/ directory:
    pageExtensions: ["tsx", "ts"],
  }
  
  module.exports = nextConfig
  


File: ./frontend/package.json
----------------------------------------
{
    "name": "pollysystem-frontend",
    "version": "1.0.0",
    "scripts": {
        "dev": "next dev",
        "build": "next build",
        "start": "next start",
        "lint": "next lint"
    },
    "dependencies": {
        "joi": "17.11.0",
        "lucide-react": "^0.468.0",
        "next": "^14.2.20",
        "react": "18.2.0",
        "react-dom": "18.2.0"
    },
    "devDependencies": {
        "@types/node": "20.10.4",
        "@types/react": "18.2.45",
        "@types/react-dom": "18.2.17",
        "autoprefixer": "^10.4.20",
        "eslint": "8.55.0",
        "eslint-config-next": "14.0.4",
        "postcss": "^8.4.49",
        "tailwindcss": "^3.4.16",
        "typescript": "5.3.3"
    }
}



File: ./frontend/public/index.html
----------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PollySystem</title>
</head>
<body>
  <div id="root"></div>
</body>
</html>



File: ./frontend/react-app-env.d.ts
----------------------------------------



File: ./frontend/src/App.tsx
----------------------------------------
import React from 'react';
import { BrowserRouter as Router, Routes, Route, NavLink } from 'react-router-dom';
import Dashboard from './pages';
import Machines from './pages/machines';
import './App.css';

function App() {
  return (
    <Router>
      <div style={{ display: 'flex', height: '100vh' }}>
        <div style={{ width: '250px', background: '#f4f4f4', padding: '10px' }}>
          <h2>PollySystem</h2>
          <nav>
            <ul style={{ listStyle: 'none', padding: 0 }}>
              <li><NavLink to="/" style={{ textDecoration: 'none', color: '#333' }}>Status</NavLink></li>
              <li><NavLink to="/machines" style={{ textDecoration: 'none', color: '#333' }}>Hosts</NavLink></li>
            </ul>
          </nav>
        </div>
        <div style={{ flex: 1, overflowY: 'auto', padding: '20px' }}>
          <Routes>
            <Route path="/" element={<Dashboard />} />
            <Route path="/machines" element={<Machines />} />
          </Routes>
        </div>
      </div>
    </Router>
  );
}

export default App;



File: ./frontend/src/components/AddMachineForm/AddMachineForm.tsx
----------------------------------------
// src/components/AddMachineForm/AddMachineForm.tsx
import React, { useState, useCallback } from 'react';
import { Check, Key, Lock, Upload, AlertCircle } from 'lucide-react';

interface AddMachineFormProps {
  onAdd: (data: {
    name: string;
    host: string;
    user: string;
    port: number;
    password?: string;
    ssh_key?: string;
  }) => Promise<void>;
}

export default function AddMachineForm({ onAdd }: AddMachineFormProps) {
  // Form state
  const [name, setName] = useState("");
  const [host, setHost] = useState("");
  const [port, setPort] = useState("22");
  const [user, setUser] = useState("root");
  const [authType, setAuthType] = useState<'password' | 'sshkey'>('sshkey');
  const [password, setPassword] = useState("");
  const [sshKey, setSshKey] = useState("");
  
  // UI state
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [uploadedFileName, setUploadedFileName] = useState<string | null>(null);

  const validateSshKey = (key: string): boolean => {
    const trimmedKey = key.trim();
    return (
      trimmedKey.includes('BEGIN') &&
      trimmedKey.includes('PRIVATE KEY') &&
      trimmedKey.includes('END')
    );
  };

  const validateForm = (): boolean => {
    if (!name.trim()) {
      setError("Name is required");
      return false;
    }
    if (!host.trim()) {
      setError("Host is required");
      return false;
    }
    if (!user.trim()) {
      setError("User is required");
      return false;
    }
    const portNum = parseInt(port);
    if (isNaN(portNum) || portNum < 1 || portNum > 65535) {
      setError("Port must be a number between 1 and 65535");
      return false;
    }
    if (authType === 'password' && !password) {
      setError("Password is required when using password authentication");
      return false;
    }
    if (authType === 'sshkey' && !sshKey) {
      setError("SSH key is required when using key authentication");
      return false;
    }
    if (authType === 'sshkey' && sshKey && !validateSshKey(sshKey)) {
      setError("Invalid SSH key format. Must be a private key file.");
      return false;
    }
    return true;
  };

  const handleFileUpload = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setIsLoading(true);
      setError(null);
      setUploadedFileName(file.name);

      const reader = new FileReader();
      
      reader.onload = (event) => {
        try {
          const content = event.target?.result as string;
          
          if (!validateSshKey(content)) {
            throw new Error('Invalid SSH key format. Must be a private key file.');
          }

          console.log('SSH key format validation:', {
            hasBegin: content.includes('BEGIN'),
            hasEnd: content.includes('END'),
            hasPrivateKey: content.includes('PRIVATE KEY'),
            lineCount: content.split('\n').length
          });

          setSshKey(content);
          setIsLoading(false);
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Failed to read SSH key');
          setSshKey('');
          setUploadedFileName(null);
          setIsLoading(false);
        }
      };

      reader.onerror = () => {
        setError('Failed to read file');
        setSshKey('');
        setUploadedFileName(null);
        setIsLoading(false);
      };

      reader.readAsText(file);
    }
  }, []);

  const clearForm = () => {
    setName("");
    setHost("");
    setPort("22");
    setUser("root");
    setPassword("");
    setSshKey("");
    setError(null);
    setUploadedFileName(null);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);

    if (!validateForm()) {
      return;
    }

    try {
      const portNum = parseInt(port);
      const data = {
        name: name.trim(),
        host: host.trim(),
        user: user.trim(),
        port: portNum,
        ...(authType === 'password' ? { password } : {
          ssh_key: sshKey.trim().endsWith('\n') ? sshKey.trim() : sshKey.trim() + '\n'
        })
      };

      setIsLoading(true);
      await onAdd(data);
      clearForm();
    } catch (err) {
      console.error('Error in form submission:', err);
      setError(err instanceof Error ? err.message : 'Failed to add machine');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4 max-w-md">
      <h3 className="text-xl font-semibold mb-4">Add Machine</h3>

      {error && (
        <div className="bg-red-50 border border-red-200 rounded-md p-4 mb-4">
          <div className="flex items-start">
            <AlertCircle className="text-red-500 mr-2 flex-shrink-0 mt-0.5" size={20} />
            <span className="text-red-700">{error}</span>
          </div>
        </div>
      )}
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">Name:</label>
        <input 
          value={name} 
          onChange={e => setName(e.target.value)} 
          required 
          placeholder="e.g., Production Server 1"
          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">Host:</label>
        <input 
          value={host} 
          onChange={e => setHost(e.target.value)} 
          required 
          placeholder="e.g., server.example.com or 192.168.1.100"
          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">Port:</label>
        <input 
          type="number"
          value={port} 
          onChange={e => setPort(e.target.value)} 
          required 
          min="1"
          max="65535"
          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">User:</label>
        <input 
          value={user} 
          onChange={e => setUser(e.target.value)} 
          required 
          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">Authentication Method:</label>
        <div className="flex space-x-4 mb-4">
          <button
            type="button"
            onClick={() => {
              setAuthType('password');
              setSshKey('');
              setUploadedFileName(null);
              setError(null);
            }}
            className={`flex items-center px-4 py-2 rounded-md transition-colors ${
              authType === 'password' 
                ? 'bg-blue-100 text-blue-700 border-blue-300' 
                : 'bg-gray-100 text-gray-700 border-gray-300'
            } border`}
          >
            <Lock size={16} className="mr-2" />
            Password
          </button>
          <button
            type="button"
            onClick={() => {
              setAuthType('sshkey');
              setPassword('');
              setError(null);
            }}
            className={`flex items-center px-4 py-2 rounded-md transition-colors ${
              authType === 'sshkey' 
                ? 'bg-blue-100 text-blue-700 border-blue-300' 
                : 'bg-gray-100 text-gray-700 border-gray-300'
            } border`}
          >
            <Key size={16} className="mr-2" />
            SSH Key
          </button>
        </div>

        {authType === 'password' ? (
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Password:</label>
            <input 
              value={password} 
              onChange={e => setPassword(e.target.value)} 
              type="password" 
              required={authType === 'password'}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
        ) : (
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">SSH Private Key:</label>
              <div className="space-y-2">
                <textarea 
                  value={sshKey} 
                  onChange={e => {
                    setSshKey(e.target.value);
                    setUploadedFileName(null);
                  }}
                  required={authType === 'sshkey'}
                  rows={8}
                  placeholder="Paste your SSH private key here"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 font-mono text-sm"
                />
                <div className="flex justify-between items-center">
                <span className="text-sm text-gray-500">- or -</span>
                  <div className="flex items-center space-x-2">
                    {uploadedFileName && (
                      <span className="text-sm text-gray-600">
                        {uploadedFileName}
                      </span>
                    )}
                    <label className={`flex items-center px-4 py-2 rounded-md cursor-pointer transition-colors ${
                      isLoading 
                        ? 'bg-gray-200 text-gray-500'
                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                    }`}>
                      <Upload size={16} className="mr-2" />
                      {isLoading ? 'Uploading...' : 'Upload Key File'}
                      <input
                        type="file"
                        onChange={handleFileUpload}
                        disabled={isLoading}
                        className="hidden"
                        accept=".key,.pem"
                      />
                    </label>
                  </div>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>

      <button 
        type="submit" 
        className="w-full flex items-center justify-center bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
        disabled={isLoading}
      >
        <Check size={16} className="mr-2" />
        {isLoading ? 'Processing...' : 'Add Machine'}
      </button>
    </form>
  );
}


File: ./frontend/src/components/CommandRunner/CommandRunner.tsx
----------------------------------------
import React, { useState } from 'react';
import { runCommandAll } from '../../lib/api';

export default function CommandRunner() {
  const [command, setCommand] = useState("");
  const [results, setResults] = useState<Record<string, string>>({});
  const [error, setError] = useState<string | null>(null);

  const handleRun = async () => {
    setError(null);
    if (!command.trim()) {
      setError("Command cannot be empty");
      return;
    }

    try {
      const res = await runCommandAll(command);
      setResults(res.results);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError("Unknown error occurred");
      }
    }
  };

  return (
    <div className="mt-8">
      <h4 className="text-lg font-semibold mb-4">Execute Command</h4>
      {error && (
        <div className="bg-red-100 border border-red-200 p-4 rounded mb-4">
          {error}
        </div>
      )}
      <div className="flex space-x-4 mb-4">
        <input
          value={command}
          onChange={e => setCommand(e.target.value)}
          placeholder="Enter command"
          className="flex-grow px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
        <button
          onClick={handleRun}
          className="bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
        >
          Run on All Hosts
        </button>
      </div>
      {Object.keys(results).length > 0 && (
        <div className="bg-gray-100 p-4 rounded-md">
          {Object.keys(results).map((host) => (
            <div key={host} className="mb-4 last:mb-0">
              <strong className="block mb-1">{host}:</strong>
              <pre className="bg-white p-2 rounded-md whitespace-pre-wrap break-all text-sm">
                {results[host]}
              </pre>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}



File: ./frontend/src/components/EnhancedMachineCard/EnhancedMachineCard.tsx
----------------------------------------
// File: ./frontend/src/components/EnhancedMachineCard/EnhancedMachineCard.tsx
import React, { useState } from 'react';
import { AlertCircle, ChevronDown, ChevronUp, Activity, HardDrive, Cpu, Server, Clock, User } from 'lucide-react';
import { ProgressBar } from '../ProgressBar/ProgressBar';

interface MachineCardProps {
  name: string;
  host: string;
  user: string;
  port: number;
  cpuUsage: number;
  memUsed: number;
  memTotal: number;
  error?: string;
  lastUpdated?: string;
}

const formatBytes = (bytes: number): string => {
  const mb = bytes / 1024 / 1024;
  return `${Math.round(mb * 100) / 100} MB`;
};

const getCPUColor = (usage: number): string => {
  if (usage >= 90) return 'bg-red-500';
  if (usage >= 70) return 'bg-orange-500';
  if (usage >= 50) return 'bg-yellow-500';
  return 'bg-green-500';
};

const getMemoryColor = (usage: number): string => {
  if (usage >= 90) return 'bg-red-500';
  if (usage >= 70) return 'bg-orange-500';
  if (usage >= 50) return 'bg-yellow-500';
  return 'bg-green-500';
};

export const EnhancedMachineCard: React.FC<MachineCardProps> = ({ 
  name, 
  host, 
  user,
  port,
  cpuUsage, 
  memUsed, 
  memTotal,
  error,
  lastUpdated
}) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const memPercent = ((memUsed / memTotal) * 100).toFixed(1);

  if (error) {
    return (
      <div className="bg-white border border-red-200 rounded-lg shadow-sm overflow-hidden">
        <div className="p-4">
          <div className="flex items-center space-x-2 mb-2">
            <AlertCircle className="text-red-500" size={20} />
            <h3 className="text-lg font-semibold">{name}</h3>
          </div>
          <p className="text-gray-600 mb-2">{host}</p>
          <p className="text-red-500 text-sm">{error}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white border border-gray-200 rounded-lg shadow-sm overflow-hidden">
      <div 
        className="p-4 cursor-pointer hover:bg-gray-50 transition-colors"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <div className="flex justify-between items-start">
          <div className="flex-1">
            <div className="flex items-center space-x-2">
              <Server className="text-gray-500" size={20} />
              <h3 className="text-lg font-semibold">{name}</h3>
            </div>
            <p className="text-gray-600 mt-1">{host}</p>
          </div>
          <button className="text-gray-400 hover:text-gray-600">
            {isExpanded ? <ChevronUp size={20} /> : <ChevronDown size={20} />}
          </button>
        </div>

        <div className="mt-4 space-y-3">
          <div>
            <div className="flex justify-between items-center mb-1">
              <div className="flex items-center space-x-2">
                <Cpu size={16} className="text-gray-500" />
                <span className="text-sm text-gray-600">CPU Usage</span>
              </div>
              <span className="text-sm font-medium">{cpuUsage.toFixed(1)}%</span>
            </div>
            <ProgressBar value={cpuUsage} max={100} color={getCPUColor(cpuUsage)} />
          </div>

          <div>
            <div className="flex justify-between items-center mb-1">
              <div className="flex items-center space-x-2">
                <HardDrive size={16} className="text-gray-500" />
                <span className="text-sm text-gray-600">Memory Usage</span>
              </div>
              <span className="text-sm font-medium">{memPercent}%</span>
            </div>
            <ProgressBar value={parseFloat(memPercent)} max={100} color={getMemoryColor(parseFloat(memPercent))} />
          </div>
        </div>
      </div>

      {isExpanded && (
        <div className="border-t border-gray-200 bg-gray-50 p-4">
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-1">
              <div className="flex items-center space-x-2 text-sm">
                <User size={16} className="text-gray-500" />
                <span className="text-gray-600">User:</span>
                <span className="font-medium">{user}</span>
              </div>
              <div className="flex items-center space-x-2 text-sm">
                <Server size={16} className="text-gray-500" />
                <span className="text-gray-600">Port:</span>
                <span className="font-medium">{port}</span>
              </div>
            </div>
            <div className="space-y-1">
              <div className="flex items-center space-x-2 text-sm">
                <Activity size={16} className="text-gray-500" />
                <span className="text-gray-600">Status:</span>
                <span className="font-medium text-green-600">Active</span>
              </div>
              <div className="flex items-center space-x-2 text-sm">
                <Clock size={16} className="text-gray-500" />
                <span className="text-gray-600">Last Updated:</span>
                <span className="font-medium">{lastUpdated || 'Just now'}</span>
              </div>
            </div>
          </div>

          <div className="mt-4 space-y-2">
            <div className="p-3 bg-white rounded border border-gray-200">
              <h4 className="text-sm font-medium text-gray-700 mb-2">Detailed Memory Usage</h4>
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <span className="text-gray-600">Used Memory:</span>
                  <span className="ml-2 font-medium">{formatBytes(memUsed * 1024 * 1024)}</span>
                </div>
                <div>
                  <span className="text-gray-600">Total Memory:</span>
                  <span className="ml-2 font-medium">{formatBytes(memTotal * 1024 * 1024)}</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};



File: ./frontend/src/components/EnhancedMachineCard/index.ts
----------------------------------------
export { EnhancedMachineCard } from './EnhancedMachineCard';


File: ./frontend/src/components/MachineCard/MachineCard.tsx
----------------------------------------
// src/components/MachineCard/MachineCard.tsx
import React from 'react';
import { AlertCircle } from 'lucide-react';

interface MachineProps {
  name: string;
  host: string;
  cpuUsage: number;
  memUsed: number;
  memTotal: number;
  error?: string;
}

export default function MachineCard({ 
  name, 
  host, 
  cpuUsage, 
  memUsed, 
  memTotal,
  error 
}: MachineProps) {
  const memPercent = ((memUsed / memTotal) * 100).toFixed(1);

  if (error) {
    return (
      <div className="bg-white border border-red-200 rounded-lg p-4 w-64 shadow-sm">
        <div className="flex items-center space-x-2 mb-2">
          <AlertCircle className="text-red-500" size={20} />
          <h3 className="text-lg font-semibold">{name}</h3>
        </div>
        <p className="text-gray-600 mb-2">{host}</p>
        <p className="text-red-500 text-sm">{error}</p>
      </div>
    );
  }

  return (
    <div className="bg-white border border-gray-200 rounded-lg p-4 w-64 shadow-sm">
      <h3 className="text-lg font-semibold mb-2">{name}</h3>
      <p className="text-gray-600 mb-4">{host}</p>
      <div className="space-y-2">
        <div className="flex justify-between items-center">
          <span className="text-sm text-gray-600">CPU:</span>
          <strong className="text-sm">{cpuUsage.toFixed(1)}%</strong>
        </div>
        <div className="flex justify-between items-center">
          <span className="text-sm text-gray-600">Memory:</span>
          <strong className="text-sm">{memUsed}/{memTotal} MB ({memPercent}%)</strong>
        </div>
      </div>
    </div>
  );
}


File: ./frontend/src/components/ProgressBar/ProgressBar.tsx
----------------------------------------
import React from 'react';

interface ProgressBarProps {
  value: number;
  max: number;
  color: string;
}

export const ProgressBar: React.FC<ProgressBarProps> = ({ value, max, color }) => {
  const percentage = Math.min(100, (value / max) * 100);
  return (
    <div className="w-full h-2 bg-gray-200 rounded-full">
      <div 
        className={`h-full rounded-full ${color}`} 
        style={{ width: `${percentage}%` }}
      />
    </div>
  );
};


File: ./frontend/src/components/Sidebar/Sidebar.tsx
----------------------------------------
import React from 'react';
import Link from 'next/link';

export default function Sidebar() {
  return (
    <nav className="bg-gray-100 p-6 h-full">
      <h2 className="text-2xl font-bold mb-6">PollySystem</h2>
      <ul className="space-y-4">
        <li>
          <Link href="/" className="text-gray-700 hover:text-black hover:underline font-medium">
            Status
          </Link>
        </li>
        <li>
          <Link href="/machines" className="text-gray-700 hover:text-black hover:underline font-medium">
            Hosts
          </Link>
        </li>
      </ul>
    </nav>
  );
}




File: ./frontend/src/index.tsx
----------------------------------------
export default function HomePage() {
    return (
      <div>
        <h1>Welcome to PollySystem</h1>
        <p>Your Next.js front-end is now serving the root page!</p>
      </div>
    );
  }
  


File: ./frontend/src/lib/api.ts
----------------------------------------
// src/lib/api.ts

interface Machine {
  id: number;
  name: string;
  host: string;
  port: number;
  user: string;
  created_at: string;
  updated_at: string | null;
}

interface MachineMetrics {
  cpu_usage_percent: number;
  memory_used_mb: number;
  memory_total_mb: number;
  status: string;
  error?: string;
}

interface MachineCreate {
  name: string;
  host: string;
  user: string;
  port?: number;
  password?: string;
  ssh_key?: string;
}

interface CommandResult {
  results: Record<string, string>;
}

export async function getMachines(): Promise<Machine[]> {
  const res = await fetch('http://localhost:8000/api/v1/machines');
  if (!res.ok) {
    const error = await res.json();
    throw new Error(error.detail || "Failed to fetch machines");
  }
  return await res.json();
}

export async function getMachineMetrics(host: string): Promise<MachineMetrics> {
  const res = await fetch(`http://localhost:8000/api/v1/machines/${host}/metrics`);
  if (!res.ok) {
    const error = await res.json();
    throw new Error(error.detail || "Failed to fetch metrics");
  }
  return await res.json();
}

export async function addMachine(data: MachineCreate): Promise<Machine> {
  const requestBody: MachineCreate = {
    name: data.name.trim(),
    host: data.host.trim(),
    user: data.user.trim(),
    port: data.port || 22
  };

  if (data.password) {
    requestBody.password = data.password;
  } else if (data.ssh_key) {
    let formattedKey = data.ssh_key.trim();
    if (!formattedKey.endsWith('\n')) {
      formattedKey += '\n';
    }
    requestBody.ssh_key = formattedKey;
  }

  const res = await fetch('http://localhost:8000/api/v1/machines', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(requestBody)
  });

  if (!res.ok) {
    const errorData = await res.json();
    console.error('Server error response:', errorData);
    throw new Error(errorData.detail || errorData.message || "Failed to add machine");
  }

  return await res.json();
}

export async function deleteMachine(host: string): Promise<{ status: string }> {
  const res = await fetch(`http://localhost:8000/api/v1/machines/${host}`, {
    method: 'DELETE'
  });

  if (!res.ok) {
    const error = await res.json();
    throw new Error(error.detail || "Failed to delete machine");
  }
  return await res.json();
}

export async function runCommandAll(command: string): Promise<CommandResult> {
  if (!command.trim()) {
    throw new Error("Command cannot be empty");
  }

  const res = await fetch('http://localhost:8000/api/v1/commands/run_all', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ command })
  });

  if (!res.ok) {
    const error = await res.json();
    // Safely handle detail
    const detailMessage = typeof error.detail === 'string'
      ? error.detail
      : JSON.stringify(error.detail);
    throw new Error(detailMessage || "Failed to run command");
  }

  return await res.json();
}



File: ./frontend/src/pages/index.tsx
----------------------------------------
import React, { useEffect, useState } from 'react';
import { getMachines, getMachineMetrics } from '../lib/api';
import { EnhancedMachineCard } from '../components/EnhancedMachineCard';
import CommandRunner from '../components/CommandRunner/CommandRunner';
import { AlertCircle } from 'lucide-react';

interface MachineState {
  id: number;
  name: string;
  host: string;
  user: string;
  port: number;
  cpuUsage: number;
  memUsed: number;
  memTotal: number;
  error?: string;
  lastUpdate?: string;
}

export default function Home() {
  const [machines, setMachines] = useState<MachineState[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchMachines = async () => {
      try {
        const machineList = await getMachines();
        const updated = await Promise.all(
          machineList.map(async (m) => {
            try {
              const metrics = await getMachineMetrics(m.host);
              return {
                ...m,
                cpuUsage: metrics.cpu_usage_percent,
                memUsed: metrics.memory_used_mb,
                memTotal: metrics.memory_total_mb,
                error: metrics.status === 'error' ? metrics.error : undefined,
                lastUpdate: new Date().toLocaleTimeString()
              };
            } catch (err) {
              console.error(`Failed to fetch metrics for ${m.host}:`, err);
              return {
                ...m,
                cpuUsage: 0,
                memUsed: 0,
                memTotal: 1,
                error: err instanceof Error ? err.message : 'Failed to fetch metrics'
              };
            }
          })
        );
        setMachines(updated);
      } catch (err) {
        console.error('Failed to fetch machines:', err);
        setError(err instanceof Error ? err.message : 'Failed to fetch machines');
      }
    };

    fetchMachines();
    const interval = setInterval(fetchMachines, 30000); // Refresh every 30 seconds

    return () => clearInterval(interval);
  }, []);

  if (error) {
    return (
      <div className="p-4 bg-red-50 border border-red-200 rounded-lg">
        <div className="flex items-center space-x-2">
          <AlertCircle className="text-red-500" size={20} />
          <h2 className="text-xl font-bold text-red-700">Error</h2>
        </div>
        <p className="text-red-600 mt-2">{error}</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold">System Status</h2>
        <div className="text-sm text-gray-500">
          Auto-refreshes every 30 seconds
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {machines.map((m) => (
          <EnhancedMachineCard
            key={m.host}
            name={m.name}
            host={m.host}
            user={m.user}
            port={m.port}
            cpuUsage={m.cpuUsage}
            memUsed={m.memUsed}
            memTotal={m.memTotal}
            error={m.error}
            lastUpdated={m.lastUpdate}
          />
        ))}
      </div>

      {machines.length === 0 && (
        <div className="text-center py-12 bg-gray-50 rounded-lg">
          <p className="text-gray-500">No machines registered yet</p>
          <p className="text-sm text-gray-400 mt-2">
            Add machines in the Hosts section to monitor them here
          </p>
        </div>
      )}

      <div className="mt-8">
        <h3 className="text-xl font-semibold mb-4">Command Center</h3>
        <CommandRunner />
      </div>
    </div>
  );
}


File: ./frontend/src/pages/machines.tsx
----------------------------------------
// src/pages/machines.tsx
import React, { useState, useEffect } from 'react';
import { getMachines, addMachine, deleteMachine } from '../lib/api';
import AddMachineForm from '../components/AddMachineForm/AddMachineForm';
import { AlertCircle, X } from 'lucide-react';

interface Machine {
  id: number;
  name: string;
  host: string;
  port: number;
  user: string;
  created_at: string;
  updated_at: string | null;
}

export default function MachinesPage() {
  const [machines, setMachines] = useState<Machine[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const loadMachines = async () => {
    try {
      const list = await getMachines();
      setMachines(list);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load machines');
    }
  };

  useEffect(() => {
    loadMachines();
  }, []);

  const handleDelete = async (host: string) => {
    if (!confirm('Are you sure you want to delete this machine?')) {
      return;
    }

    try {
      await deleteMachine(host);
      await loadMachines();
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to delete machine');
    }
  };

  const handleAdd = async (data: {
    name: string;
    host: string;
    user: string;
    port: number;
    password?: string;
    ssh_key?: string;
  }) => {
    setIsLoading(true);
    try {
      await addMachine(data);
      await loadMachines();
      setError(null);
    } catch (err) {
      console.error('Error adding machine:', err);
      setError(err instanceof Error ? err.message : 'Failed to add machine');
      throw err; // Re-throw to let the form handle the error state
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div>
      <h2 className="text-2xl font-bold mb-4">Hosts</h2>
      
      {error && (
        <div className="mb-4 p-4 bg-red-50 border border-red-200 rounded-lg relative">
          <div className="flex items-start">
            <AlertCircle className="text-red-500 mr-2 flex-shrink-0 mt-0.5" size={20} />
            <div className="flex-grow">
              <h3 className="text-red-700 font-semibold">Error</h3>
              <p className="text-red-600">{error}</p>
            </div>
          </div>
          <button 
            onClick={() => setError(null)}
            className="absolute top-4 right-4 text-red-400 hover:text-red-600"
          >
            <X size={16} />
          </button>
        </div>
      )}

      <AddMachineForm onAdd={handleAdd} />
      
      <div className="mt-8">
        <h3 className="text-lg font-semibold mb-4">Registered Hosts</h3>
        <div className="space-y-2">
          {machines.map((machine) => (
            <div 
              key={machine.host} 
              className="flex items-center justify-between bg-white p-4 rounded-lg shadow"
            >
              <div className="space-y-1">
                <div>
                  <strong className="text-lg">{machine.name}</strong>
                  <span className="ml-2 text-gray-600">({machine.host})</span>
                </div>
                <div className="text-sm text-gray-500">
                  {machine.user}@{machine.host}:{machine.port}
                </div>
              </div>
              <button 
                onClick={() => handleDelete(machine.host)} 
                className="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 transition-colors"
                disabled={isLoading}
              >
                Delete
              </button>
            </div>
          ))}
          {machines.length === 0 && (
            <div className="text-gray-500 text-center py-8 bg-gray-50 rounded-lg">
              No machines registered yet
            </div>
          )}
        </div>
      </div>
    </div>
  );
}


File: ./frontend/src/pages/_app.tsx
----------------------------------------
import '../../styles/globals.css';
import type { AppProps } from 'next/app';
import Sidebar from '../components/Sidebar/Sidebar';

export default function MyApp({ Component, pageProps }: AppProps) {
  return (
    <div className="flex h-screen">
      <Sidebar />
      <main className="flex-1 overflow-y-auto p-8">
        <Component {...pageProps} />
      </main>
    </div>
  );
}




File: ./frontend/styles/globals.css
----------------------------------------
@tailwind base;
@tailwind components;
@tailwind utilities;



File: ./frontend/tailwind.config.js
----------------------------------------
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
    './src/lib/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}


File: ./frontend/tsconfig.json
----------------------------------------
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": false,
    "skipLibCheck": true,
    "strict": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "noEmit": true,
    "incremental": true,
    "esModuleInterop": true
  },
  "include": [
    "next-env.d.ts",
    "src/**/*",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}



File: ./scripts/deployment.sh
----------------------------------------
#!/usr/bin/env bash
# Placeholder for future CI/CD deployment steps
echo "Deployment script (implement as needed)"



File: ./scripts/docker_install_check.sh
----------------------------------------
#!/usr/bin/env bash
set -e
sudo apt-get update && sudo apt upgrade -y && sudo apt-get install -y ca-certificates curl gnupg git
sudo install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo chmod a+r /etc/apt/keyrings/docker.gpg
echo "deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \"$(. /etc/os-release && echo \"$VERSION_CODENAME\")\" stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update && sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
sudo groupadd docker || true
sudo usermod -aG docker $USER
newgrp docker
sudo chown "$USER":"$USER" /home/"$USER"/.docker -R || true
sudo chmod g+rwx "$HOME/.docker" -R || true
sudo systemctl enable docker.service
sudo systemctl enable containerd.service



